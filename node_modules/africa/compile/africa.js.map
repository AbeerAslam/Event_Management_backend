{
"version":3,
"file":"compile/africa.js",
"lineCount":317,
"mappings":"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",
"sources":["node_modules/path/index.js","node_modules/os/index.js","node_modules/util/index.js","node_modules/fs/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/@wrote/write/src/index.js","node_modules/bosom/src/index.js","node_modules/makepromise/src/index.js","node_modules/@wrote/exists/src/index.js","node_modules/readline/index.js","node_modules/promto/src/index.js","node_modules/reloquent/src/lib/ask.js","node_modules/reloquent/src/lib/ask-questions.js","node_modules/reloquent/src/index.js","src/lib/Group.js","src/lib/index.js","src/index.js","src/depack.js","src$/index.js"],
"sourcesContent":["export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","export default util\nexport const {\n  TextDecoder,\n  TextEncoder,\n  callbackify,\n  debug,\n  debuglog,\n  deprecate,\n  error,\n  format,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray,\n  isBoolean,\n  isBuffer,\n  isDate,\n  isError,\n  isFunction,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isPrimitive,\n  isRegExp,\n  isString,\n  isSymbol,\n  isUndefined,\n  log,\n  print,\n  promisify,\n  puts,\n} = util","export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","import { debuglog } from 'util'\nimport read from '@wrote/read'\nimport write from '@wrote/write'\n\nconst LOG = debuglog('bosom')\n\nconst writeJSON = async (path, data, config) => {\n  const {\n    replacer = null,\n    space = null,\n  } = config\n  const json = JSON.stringify(data, replacer, space)\n  await write(path, json)\n}\n\n/**\n * Read or write a JSON file.\n * @param {string} path Path to the file to read.\n * @param {Object} [data] Data to write to the file (if JSON file exists, fields in it will be overridden).\n * @param {!_bosom.Options} [config] how to write data.\n */\nconst bosom = async (path, data, config = {}) => {\n  if (data) {\n    const res = await writeJSON(path, data, config)\n    return res\n  }\n  LOG('Reading %s', path)\n  const r = await read(path)\n  const res = JSON.parse(r)\n  return res\n}\n\nexport default bosom\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Options} _bosom.Options\n */","import erotic from 'erotic'\n\n// /**\n//  * @param {number} length\n//  * @param {number} i\n//  * @param {!Function} fn\n//  */\n// function checkArgumentIndex(length, i, fn) {\n//   if (i > length - 2) {\n//     throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept that many arguments (max ${length - 1} + callback).`)\n//   }\n// }\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn != 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept any arguments.`)\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      // args.forEach((arg, i) => {\n      //   checkArgumentIndex(fnLength, i, fn)\n      // })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      // checkArgumentIndex(fnLength, 0, fn)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","export default readline\nexport const {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n} = readline","function createTimeout(desc, timeout, cb) {\n  return setTimeout(() => {\n    const message = `${desc ? desc : 'Promise'} has timed out after ${timeout}ms`\n    const err = new Error(message)\n    err.stack = `Error: ${err.message}`\n    cb(err)\n  }, timeout)\n}\n\nfunction makeTimeoutPromise(desc, timeout) {\n  let to\n  const promise = new Promise((_, reject) => {\n    to = createTimeout(desc, timeout, reject)\n  })\n  return { timeout: to, promise }\n}\n\n/**\n * Create a promise which will be rejected after a timeout.\n * @param {!Promise<T>} promise A promise to race with\n * @param {number} timeout Timeout in ms after which to reject\n * @param {string} [desc] Description of a promise to be printed in error\n * @returns {!Promise<T>} A promise with a timeout\n * @template T\n */\nexport default async function createPromiseWithTimeout(promise, timeout, desc) {\n  if (!(promise instanceof Promise))\n    throw new Error('Promise expected')\n  if (!timeout)\n    throw new Error('Timeout must be a number')\n  if (timeout < 0)\n    throw new Error('Timeout cannot be negative')\n\n  const { promise: toPromise, timeout: to } = makeTimeoutPromise(desc, timeout)\n  try {\n    return await Promise.race([\n      promise,\n      toPromise,\n    ])\n  } finally {\n    clearTimeout(to)\n  }\n}","import { createInterface } from 'readline'\r\nimport promto from 'promto'\r\n\r\n/**\r\n * Ask user a question and wait for an answer.\r\n * @param {string} question Question to present to the user.\r\n * @param {{ password: (boolean| undefined), timeout: (number|undefined), input: (stream.Readable|NodeJS.ReadStream|undefined), output: (stream.Writable|NodeJS.WriteStream|undefined) }} options The options.\r\n */\r\nexport default function ask(question, options = {}) {\r\n  const {\r\n    timeout,\r\n    password = false,\r\n    output = process.stdout,\r\n    input = process.stdin,\r\n    ...rest\r\n  } = options\r\n  const rl = createInterface(/** @type {!readline.ReadLineOptions} */ ({\r\n    input,\r\n    output,\r\n    ...rest,\r\n  }))\r\n  if (password) {\r\n    /**\r\n     * Undocumented API.\r\n     * @type {!NodeJS.WriteStream}\r\n     * @suppress {checkTypes}\r\n     */\r\n    const o = rl['output']\r\n    /**\r\n     * Undocumented API.\r\n     * @suppress {checkTypes}\r\n     */\r\n    rl['_writeToOutput'] = (s) => {\r\n      if (['\\r\\n', '\\n', '\\r'].includes(s))\r\n        return o.write(s)\r\n\r\n      const v = s.split(question)\r\n      if (v.length == '2') {\r\n        o.write(question)\r\n        o.write('*'.repeat(v[1].length))\r\n      } else {\r\n        o.write('*')\r\n      }\r\n    }\r\n  }\r\n  const p = new Promise((r) => {\r\n    rl.question(question, r)\r\n  })\r\n\r\n  let promise\r\n  if (timeout) {\r\n    promise = promto(p, timeout, `reloquent: ${question}`)\r\n  } else {\r\n    promise = p\r\n  }\r\n  /**\r\n   * @suppress {checkTypes}\r\n   */\r\n  rl['promise'] = tryPromise(promise, rl)\r\n  return rl\r\n}\r\n\r\n/**\r\n * \r\n * @param {!Promise} promise \r\n * @param {!readline.Interface} rl \r\n */\r\nconst tryPromise = async (promise, rl) => {\r\n  try {\r\n    const res = await promise\r\n    return res\r\n  } finally {\r\n    rl.close()\r\n  }\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Readable} stream.Readable\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Writable} stream.Writable\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('readline').ReadLineOptions} readline.ReadLineOptions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('readline').Interface} readline.Interface\r\n */","import ask from './ask'\r\n\r\n/**\r\n * Color foreground with grey\r\n * @param {string} t\r\n */\r\nexport function c(t) {\r\n  return `\\x1b[90m${t}\\x1b[0m`\r\n}\r\n\r\n/**\r\n * Ask a set of questions.\r\n * @param {_reloquent.Questions} questions An object with questions as values\r\n * @param {number} [timeout] How long to wait before answer\r\n * @returns {!Promise<!Object<string, string>>} A promise where keys from the questions object are validated, assigned default values if required, and populated with answers. Validation function should either throw or return nothing, or throw an error.\r\n */\r\nexport default async function askQuestions(questions, timeout) {\r\n  if (typeof questions != 'object')\r\n    throw new Error('Please give an object with questions')\r\n\r\n  const keys = Object.keys(/** @type {!Object} */ (questions))\r\n  const res = await keys.reduce(async (acc, key) => {\r\n    const accRes = await acc\r\n\r\n    const value = questions[key]\r\n    /** @type {!_reloquent.Question} */\r\n    let question\r\n    switch (typeof value) {\r\n    case 'object':\r\n      question = /** @type {!_reloquent.Question} */ ({ ...value })\r\n      break\r\n    case 'string':\r\n      question = { text: value }\r\n      break\r\n    default:\r\n      throw new Error('A question must be a string or an object.')\r\n    }\r\n\r\n    question.text = `${question.text}${question.text.endsWith('?') ? '' : ':'} `\r\n\r\n    let defaultValue\r\n    let gotDefaultValue\r\n    if (question.defaultValue) {\r\n      defaultValue = question.defaultValue\r\n    }\r\n    if (question.getDefault) {\r\n      gotDefaultValue = await question.getDefault()\r\n    }\r\n\r\n    let dv = defaultValue || ''\r\n    if (defaultValue && gotDefaultValue && defaultValue != gotDefaultValue) {\r\n      dv = c(defaultValue)\r\n    } else if (defaultValue && defaultValue == gotDefaultValue) {\r\n      dv = ''\r\n    }\r\n    let gtd = gotDefaultValue || ''\r\n    const text = `${question.text}${dv ? `[${dv}] ` : ''}${gtd ? `[${gtd}] ` : ''}`\r\n    const { 'promise': promise } = ask(text, {\r\n      timeout,\r\n      password: question.password,\r\n      ...question,\r\n    })\r\n\r\n    const a = await promise\r\n    let answer = a || gotDefaultValue || question.defaultValue\r\n\r\n    if (typeof question.validation == 'function') {\r\n      question.validation(answer)\r\n    }\r\n    if (typeof question.postProcess == 'function') {\r\n      answer = await question.postProcess(answer)\r\n    }\r\n    return {\r\n      ...accRes,\r\n      [key]: answer,\r\n    }\r\n  }, {})\r\n\r\n  return res\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../..').Questions} _reloquent.Questions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../..').Question} _reloquent.Question\r\n */","import askQuestions from './lib/ask-questions'\r\n\r\n/**\r\n * @type {_reloquent.askQuestions}\r\n */\r\nexport default async function reloquent(questions, timeout) {\r\n  const res = await askQuestions(questions, timeout)\r\n  return res\r\n}\r\n\r\n/**\r\n * @type {_reloquent.askSingle}\r\n */\r\nexport async function askSingle(question, timeout) {\r\n  const { question: answer } = await askQuestions({ question }, timeout)\r\n  return answer\r\n}\r\n\r\n/**\r\n * @type {_reloquent.confirm}\r\n */\r\nexport async function confirm(question, options = {}) {\r\n  const {\r\n    defaultYes = true,\r\n    timeout,\r\n  } = options\r\n  const Q = typeof question == 'string' ? {\r\n    text: question,\r\n  } : question\r\n  const { text } = Q\r\n  const hasQ = text.endsWith('?')\r\n  const realText = `${hasQ ? text.replace(/\\?$/, '') : text} (y/n)${hasQ ? '?' : ''}`\r\n  const { question: answer } = await askQuestions({\r\n    question: {\r\n      defaultValue: defaultYes ? 'y' : 'n',\r\n      ...Q,\r\n      text: realText,\r\n    },\r\n  }, timeout)\r\n  return answer == 'y'\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').ConfirmOptions} _reloquent.ConfirmOptions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').Question} _reloquent.Question\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').Questions} _reloquent.Questions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').askSingle} _reloquent.askSingle\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').confirm} _reloquent.confirm\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').askQuestions} _reloquent.askQuestions\r\n */\r\n","export default class Group {\n  /**\n   * Create a group of questions.\n   * @param {_reloquent.Questions} questions A set of questions in a group.\n   */\n  constructor(questions) {\n    this.questions = questions\n  }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../..').Questions} _reloquent.Questions\n */\n","import ask from 'reloquent'\nimport bosom from 'bosom'\nimport Group from './Group'\n\n/**\n * Ask questions and write answers to the RC file.\n * @param {_reloquent.Questions} questions The set of questions. These need to be updated to include defaults.\n * @param {string} path The path for the RC file.\n * @param {{\n * skipExisting: (boolean|undefined),\n * config: (!Object|undefined),\n * timeout: (number|undefined)\n * }} [options] Additional options.\n */\nexport async function askQuestionsAndWrite(questions, path, {\n  skipExisting = false, config = {}, timeout,\n} = {}) {\n  /** @type {!Object<string, !Group>} */\n  const groups = {}\n\n  let current = {}\n\n  const q = Object.entries(questions).reduce((acc, [key, question]) => {\n    if (question instanceof Group) {\n      groups[key] = question\n      return acc\n    }\n    acc[key] = question\n    return acc\n  }, {})\n\n  let answers = await ask(q, timeout)\n\n  try {\n    current = await bosom(path)\n  } catch (err) {\n    // ok\n  }\n\n  if (skipExisting) {\n    answers = skipAnswers(answers, config, current) || {}\n  }\n\n  const ga = await Object.entries(groups).reduce(async (acc, [key, group]) => {\n    acc = await acc\n    let g = await ask(group.questions, timeout)\n    if (skipExisting) g = skipAnswers(g, config[key], current[key])\n    if (g) acc[key] = g\n    return acc\n  }, {})\n\n  // answers not from questions but in config anyhow\n\n  const extra = skipAnswers(current, config, current) || {}\n  const total = { ...extra, ...answers, ...ga }\n  await bosom(path, total, { space: 2 })\n  return total\n}\n\nconst skipAnswers = (answers, config = {}, current = {}) => {\n  let allSkipped = true\n  const skipped = Object.entries(answers).reduce((acc, [key, val]) => {\n    const CURRENT = current[key]\n    const DEFAULT = config[key]\n\n    if (val == DEFAULT && val != CURRENT) return acc\n    allSkipped = false\n    acc[key] = val\n    return acc\n  }, {})\n  if (allSkipped) return null\n  return skipped\n}\n\n/**\n * Merge two configurations, with `a` as base one, such that its properties won't be overridden by `b`.\n * @param {!Object} a The base configuration.\n * @param {!Object} b The extension to configuration.\n */\nexport const merge = (a, b) => {\n  return Object.entries(b).reduce((acc, [k, value]) => {\n    if (typeof value == 'object' && value !== null && typeof a[k] == 'object') {\n      acc[k] = merge(a[k], value)\n    }\n    else acc[k] = value\n    return acc\n  }, a)\n}\n\n/**\n * Adds default value from the config.\n * @param {_reloquent.Questions} questions A set of questions to extend with default value from the existing config.\n * @param {!Object} current Current configuration object (answers).\n * @returns {_reloquent.Questions} Questions with updated defaultValue where answers were present in the passed config object.\n */\nconst extendQuestions = (questions, current) => {\n  const q = Object.entries(questions).reduce((acc, [key, question]) => {\n    const defaultValue = current[key]\n    if (!defaultValue) {\n      acc[key] = question\n      return acc\n    }\n\n    let value = typeof question == 'string' ? { text: question } : question\n    if (question instanceof Group) {\n      question.questions = extendQuestions(question.questions, defaultValue)\n    } else {\n      value = { ...value, defaultValue }\n    }\n\n    acc[key] = value\n    return acc\n  }, {})\n  return q\n}\n\n/**\n * Ask questions while adding default values when asking.\n * @param {_reloquent.Questions} questions\n * @param {string} path The path to the rc file.\n * @param {!Object} config Current answers.\n * @param {number} [timeout]\n * @param {{ skipExisting: (boolean|undefined) }} [opts]\n */\nexport const forceQuestions = async (questions, path, config, timeout, { skipExisting } = {}) => {\n  const q = extendQuestions(questions, config)\n  const conf = await askQuestionsAndWrite(q, path, { timeout, skipExisting, config })\n  return conf\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../..').Questions} _reloquent.Questions\n */\n\n","import { resolve } from 'path'\nimport { homedir as home } from 'os'\nimport bosom from 'bosom'\nimport exists from '@wrote/exists'\nimport { Recursive } from '../src$'\nimport { askQuestionsAndWrite, merge, forceQuestions } from './lib'\n\n/**\n * @type {_africa.africa}\n */\nexport default async function africa(packageName, questions = {}, config = {}) {\n  if (typeof packageName != 'string')\n    throw new Error('Package name is required.')\n\n  const {\n    homedir = home(),\n    rcNameFunction = p => `.${p}rc`,\n    force = false,\n    local = false,\n    questionsTimeout: timeout,\n  } = config\n\n  let { recursive = false } = config\n\n  if (recursive) {\n    if (!process.cwd().startsWith(resolve(homedir))) {\n      console.error('The path %s is not under `homedir` which is %s. Settings merging via `recursive` won\\'t work.',\n        process.cwd(), resolve(homedir))\n      recursive = false\n      // throw new Error('To use recursive feature, your cwd needs to be inside HOME.')\n    }\n  }\n\n  const RC = rcNameFunction(packageName)\n  const path = resolve(homedir, RC)\n  const LOCAL_PATH = resolve(RC)\n\n  const homeEx = await exists(path)\n\n  if (local) {\n    const c = await handleLocal(homeEx, path, LOCAL_PATH, questions, timeout, force)\n    return c\n  }\n\n  if (recursive) {\n    return Recursive(RC, LOCAL_PATH, questions, config)\n  }\n\n  const c = await handleHome(homeEx, path, questions, timeout, force)\n  return c\n}\n\nconst handleHome = async (homeEx, path, questions, timeout, force) => {\n  if (!homeEx) {\n    const conf = await askQuestionsAndWrite(questions, path, { timeout })\n    return conf\n  }\n  const p = await getParsed(path, questions, force, timeout)\n  return p\n}\n\n// todo: move groups to reloquent.\n\n/**\n * Parse configuration file from the filesystem.\n * @param {string} path The path to the JSON file to parse.\n * @param {_reloquent.Questions} questions\n * @param {boolean} force\n * @param {number|undefined} [timeout]\n * @param {!Object} [extra]\n */\nconst getParsed = async (path, questions, force, timeout, extra = {}) => {\n  const parsed = await bosom(path)\n  const all = merge(parsed, extra)\n  if (force) {\n    const c = await forceQuestions(questions, path, all, timeout)\n    return c\n  }\n  return all\n}\n\nconst handleLocal = async (homeEx, path, localPath, questions, timeout, force) => {\n  const localEx = await exists(localPath)\n  if (!localEx) {\n    const h = homeEx ? await bosom(path) : {}\n    const conf = await forceQuestions(questions, localPath, h, timeout)\n    return conf\n  }\n  const p = await getParsed(localPath, questions, force, timeout)\n  return p\n}\n\nexport { default as Group } from './lib/Group'\n\n\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Questions} _reloquent.Questions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').africa} _africa.africa\n */","/* eslint-disable quote-props */\nimport '../types/externs'\nimport africa from './'\nimport Group from './lib/Group'\n\nmodule.exports = {\n  '__africa': africa,\n  '_Group': Group,\n}","export function Recursive(RC, LOCAL_PATH, questions, config) {\n  console.log('The `recursive` feature is only available in the paid version.')\n  return {}\n}"],
"names":["resolve","path","homedir","os","debuglog","util","createReadStream","fs","createWriteStream","lstat","Writable","stream","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","er","proxyError","wrap","_","_caughtData","_promise","Promise","r","on","d","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","res","read","write","data","ws","err","end","LOG","writeJSON","config","replacer","space","json","JSON","stringify","bosom","parse","makePromise","fn","resolveValue","fnLength","name","reject","error","allArgs","Array","isArray","exists","ls","createInterface","readline","createTimeout","desc","timeout","setTimeout","makeTimeoutPromise","to","createPromiseWithTimeout","toPromise","race","clearTimeout","ask","question","password","output","process","stdout","input","stdin","rest","rl","o","s","v","repeat","p","promto","tryPromise","close","askQuestions","questions","keys","reduce","acc","key","accRes","value","text","endsWith","gotDefaultValue","defaultValue","getDefault","dv","gtd","answer","a","validation","postProcess","reloquent","Group","askQuestionsAndWrite","skipExisting","groups","current","q","entries","answers","skipAnswers","ga","group","g","total","allSkipped","skipped","val","CURRENT","DEFAULT","merge","b","k","extendQuestions","forceQuestions","conf","handleHome","homeEx","force","getParsed","parsed","all","extra","c","handleLocal","localPath","localEx","h","module","exports","africa","packageName","home","rcNameFunction","local","recursive","cwd","startsWith","console","RC","LOCAL_PATH","log"]
}
