#!/usr/bin/env node
             
const path = require('path');
const os = require('os');
const util = require('util');
const fs = require('fs');
const stream = require('stream');
const readline = require('readline');             
const n = path.resolve;
const p = os.homedir;
const q = util.debuglog;
const r = fs.createReadStream, t = fs.createWriteStream, u = fs.lstat;
const v = stream.Writable;
const w = (a, b = 0, d = !1) => {
  if (0 === b && !d) {
    return a;
  }
  a = a.split("\n", d ? b + 1 : void 0);
  return d ? a[a.length - 1] : a.slice(b).join("\n");
}, x = (a, b = !1) => w(a, 2 + (b ? 1 : 0)), y = a => {
  ({callee:{caller:a}} = a);
  return a;
};
const z = /\s+at.*(?:\(|\s)(.*)\)?/, A = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:IGNORED_MODULES)\/.*)?\w+)\.js:\d+:\d+)|native)/, B = p(), C = a => {
  const {pretty:b = !1, ignoredModules:d = ["pirates"]} = {}, e = d.join("|"), c = new RegExp(A.source.replace("IGNORED_MODULES", e));
  return a.replace(/\\/g, "/").split("\n").filter(f => {
    f = f.match(z);
    if (null === f || !f[1]) {
      return !0;
    }
    f = f[1];
    return f.includes(".app/Contents/Resources/electron.asar") || f.includes(".app/Contents/Resources/default_app.asar") ? !1 : !c.test(f);
  }).filter(f => f.trim()).map(f => b ? f.replace(z, (g, h) => g.replace(h, h.replace(B, "~"))) : f).join("\n");
};
function D(a, b, d = !1) {
  return function(e) {
    var c = y(arguments), {stack:f} = Error();
    const g = w(f, 2, !0), h = (f = e instanceof Error) ? e.message : e;
    c = [`Error: ${h}`, ...null !== c && a === c || d ? [b] : [g, b]].join("\n");
    c = C(c);
    return Object.assign(f ? e : Error(), {message:h, stack:c});
  };
}
;function E(a) {
  var {stack:b} = Error();
  const d = y(arguments);
  b = x(b, a);
  return D(d, b, a);
}
;const F = (a, b) => {
  b.once("error", d => {
    a.emit("error", d);
  });
  return b;
};
class G extends v {
  constructor(a) {
    const {binary:b = !1, rs:d = null, ...e} = a || {}, {f:c = E(!0), proxyError:f} = a || {}, g = (h, k) => c(k);
    super(e);
    this.a = [];
    this.c = new Promise((h, k) => {
      this.on("finish", () => {
        let l;
        b ? l = Buffer.concat(this.a) : l = this.a.join("");
        h(l);
        this.a = [];
      });
      this.once("error", l => {
        if (-1 == l.stack.indexOf("\n")) {
          g`${l}`;
        } else {
          const m = C(l.stack);
          l.stack = m;
          f && g`${l}`;
        }
        k(l);
      });
      d && F(this, d).pipe(this);
    });
  }
  _write(a, b, d) {
    this.a.push(a);
    d();
  }
  get b() {
    return this.c;
  }
}
const H = async a => {
  ({b:a} = new G({rs:a, f:E(!0)}));
  return await a;
};
async function I(a) {
  a = r(a);
  return await H(a);
}
;async function J(a, b) {
  if (!a) {
    throw Error("No path is given.");
  }
  const d = E(!0), e = t(a);
  await new Promise((c, f) => {
    e.on("error", g => {
      g = d(g);
      f(g);
    }).on("close", c).end(b);
  });
}
;const K = q("bosom"), L = async(a, b, d) => {
  const {replacer:e = null, space:c = null} = d;
  b = JSON.stringify(b, e, c);
  await J(a, b);
}, M = async(a, b, d = {}) => {
  if (b) {
    return await L(a, b, d);
  }
  K("Reading %s", a);
  a = await I(a);
  return JSON.parse(a);
};
async function N(a, b, d) {
  const e = E(!0);
  if ("function" != typeof a) {
    throw Error("Function must be passed.");
  }
  if (!a.length) {
    throw Error(`Function${a.name ? ` ${a.name}` : ""} does not accept any arguments.`);
  }
  return await new Promise((c, f) => {
    const g = (k, l) => k ? (k = e(k), f(k)) : c(d || l);
    let h = [g];
    Array.isArray(b) ? h = [...b, g] : 1 < Array.from(arguments).length && (h = [b, g]);
    a(...h);
  });
}
;const O = async a => {
  try {
    return await N(u, a);
  } catch (b) {
    return null;
  }
};
const P = readline.createInterface;
function Q(a, b, d) {
  return setTimeout(() => {
    const e = Error(`${a ? a : "Promise"} has timed out after ${b}ms`);
    e.stack = `Error: ${e.message}`;
    d(e);
  }, b);
}
function R(a, b) {
  let d;
  const e = new Promise((c, f) => {
    d = Q(a, b, f);
  });
  return {timeout:d, b:e};
}
async function aa(a, b, d) {
  if (!(a instanceof Promise)) {
    throw Error("Promise expected");
  }
  if (!b) {
    throw Error("Timeout must be a number");
  }
  if (0 > b) {
    throw Error("Timeout cannot be negative");
  }
  const {b:e, timeout:c} = R(d, b);
  try {
    return await Promise.race([a, e]);
  } finally {
    clearTimeout(c);
  }
}
;function ba(a, b = {}) {
  const {timeout:d, password:e = !1, output:c = process.stdout, input:f = process.stdin, ...g} = b, h = P({input:f, output:c, ...g});
  if (e) {
    const k = h.output;
    h._writeToOutput = l => {
      if (["\r\n", "\n", "\r"].includes(l)) {
        return k.write(l);
      }
      l = l.split(a);
      "2" == l.length ? (k.write(a), k.write("*".repeat(l[1].length))) : k.write("*");
    };
  }
  b = new Promise(k => {
    h.question(a, k);
  });
  b = d ? aa(b, d, `reloquent: ${a}`) : b;
  h.promise = ca(b, h);
  return h;
}
const ca = async(a, b) => {
  try {
    return await a;
  } finally {
    b.close();
  }
};
async function da(a, b) {
  if ("object" != typeof a) {
    throw Error("Please give an object with questions");
  }
  return await Object.keys(a).reduce(async(d, e) => {
    d = await d;
    var c = a[e];
    switch(typeof c) {
      case "object":
        c = {...c};
        break;
      case "string":
        c = {text:c};
        break;
      default:
        throw Error("A question must be a string or an object.");
    }
    c.text = `${c.text}${c.text.endsWith("?") ? "" : ":"} `;
    var f;
    if (c.defaultValue) {
      var g = c.defaultValue;
    }
    c.getDefault && (f = await c.getDefault());
    let h = g || "";
    g && f && g != f ? h = `\x1b[90m${g}\x1b[0m` : g && g == f && (h = "");
    g = f || "";
    ({promise:g} = ba(`${c.text}${h ? `[${h}] ` : ""}${g ? `[${g}] ` : ""}`, {timeout:b, password:c.password, ...c}));
    f = await g || f || c.defaultValue;
    "function" == typeof c.validation && c.validation(f);
    "function" == typeof c.postProcess && (f = await c.postProcess(f));
    return {...d, [e]:f};
  }, {});
}
;async function S(a, b) {
  return await da(a, b);
}
;class T {
  constructor(a) {
    this.questions = a;
  }
}
;async function U(a, b, {skipExisting:d = !1, config:e = {}, timeout:c} = {}) {
  const f = {};
  let g = {};
  a = Object.entries(a).reduce((k, [l, m]) => {
    if (m instanceof T) {
      return f[l] = m, k;
    }
    k[l] = m;
    return k;
  }, {});
  a = await S(a, c);
  try {
    g = await M(b);
  } catch (k) {
  }
  d && (a = V(a, e, g) || {});
  const h = await Object.entries(f).reduce(async(k, [l, m]) => {
    k = await k;
    m = await S(m.questions, c);
    d && (m = V(m, e[l], g[l]));
    m && (k[l] = m);
    return k;
  }, {});
  a = {...V(g, e, g) || {}, ...a, ...h};
  await M(b, a, {space:2});
  return a;
}
const V = (a, b = {}, d = {}) => {
  let e = !0;
  a = Object.entries(a).reduce((c, [f, g]) => {
    const h = d[f];
    if (g == b[f] && g != h) {
      return c;
    }
    e = !1;
    c[f] = g;
    return c;
  }, {});
  return e ? null : a;
}, W = (a, b) => Object.entries(b).reduce((d, [e, c]) => {
  d[e] = "object" == typeof c && null !== c && "object" == typeof a[e] ? W(a[e], c) : c;
  return d;
}, a), X = (a, b) => Object.entries(a).reduce((d, [e, c]) => {
  const f = b[e];
  if (!f) {
    return d[e] = c, d;
  }
  let g = "string" == typeof c ? {text:c} : c;
  c instanceof T ? c.questions = X(c.questions, f) : g = {...g, defaultValue:f};
  d[e] = g;
  return d;
}, {}), Y = async(a, b, d, e) => {
  var {skipExisting:c} = {};
  a = X(a, d);
  return await U(a, b, {timeout:e, skipExisting:c, config:d});
};
const ea = async(a, b, d, e, c) => a ? await Z(b, d, c, e) : await U(d, b, {timeout:e}), Z = async(a, b, d, e) => {
  var c = await M(a);
  c = W(c, {});
  return d ? await Y(b, a, c, e) : c;
}, fa = async(a, b, d, e, c, f) => await O(d) ? await Z(d, e, f, c) : (a = a ? await M(b) : {}, await Y(e, d, a, c));
module.exports = {__africa:async function(a, b = {}, d = {}) {
  if ("string" != typeof a) {
    throw Error("Package name is required.");
  }
  const {homedir:e = p(), rcNameFunction:c = m => `.${m}rc`, force:f = !1, local:g = !1, questionsTimeout:h} = d;
  ({recursive:d = !1} = d);
  d && !process.cwd().startsWith(n(e)) && (console.error("The path %s is not under `homedir` which is %s. Settings merging via `recursive` won't work.", process.cwd(), n(e)), d = !1);
  var k = c(a);
  a = n(e, k);
  k = n(k);
  const l = await O(a);
  g ? b = await fa(l, a, k, b, h, f) : d ? (console.log("The `recursive` feature is only available in the paid version."), b = {}) : b = await ea(l, a, b, h, f);
  return b;
}, _Group:T};


//# sourceMappingURL=africa.js.map